<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[MIT 6.824 分布式系统课程] Lab2 Raft 心得 | 九原山</title><meta name=keywords content="blog,done"><meta name=description content="Raft struct 的成员 1 Raft 节点的角色，可以使用Go常量
const ( Follower = iota // 0 Candidate	// 1 Leader	// 2 ) 2 使用Buffered Channel进行异步通信，比如等待心跳包结果等情况，我定义了如下Channel
chanHeartbeat chan bool // 收到心跳 chanWinVote chan bool	// 赢得选举 chanGrantVote chan bool // 获得选举票 chanApply chan ApplyMsg // 用来commit的channel 在Make()中需要初始化Channel为Buffered Channel
rf.chanWinVote = make(chan bool, 10) rf.chanGrantVote = make(chan bool, 10) rf.chanHeartbeat = make(chan bool, 10) 3 Raft struct大部分成员都是论文的Figure 2的内容
4 发送broadcastRequestVote后，需要进行voteCount 计数，以确定是否赢得Vote，所以 Raft struct需要增加voteCount成员
协程冲突问题 Raft有如下成员来进行加锁"><meta name=author content><link rel=canonical href=https://ninehills.tech/posts/ninehills-ninehills.github.io-300952316-post-62/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ninehills.tech/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ninehills.tech/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ninehills.tech/favicon-32x32.png><link rel=apple-touch-icon href=https://ninehills.tech/apple-touch-icon.png><link rel=mask-icon href=https://ninehills.tech/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.112.6"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="[MIT 6.824 分布式系统课程] Lab2 Raft 心得"><meta property="og:description" content="Raft struct 的成员 1 Raft 节点的角色，可以使用Go常量
const ( Follower = iota // 0 Candidate	// 1 Leader	// 2 ) 2 使用Buffered Channel进行异步通信，比如等待心跳包结果等情况，我定义了如下Channel
chanHeartbeat chan bool // 收到心跳 chanWinVote chan bool	// 赢得选举 chanGrantVote chan bool // 获得选举票 chanApply chan ApplyMsg // 用来commit的channel 在Make()中需要初始化Channel为Buffered Channel
rf.chanWinVote = make(chan bool, 10) rf.chanGrantVote = make(chan bool, 10) rf.chanHeartbeat = make(chan bool, 10) 3 Raft struct大部分成员都是论文的Figure 2的内容
4 发送broadcastRequestVote后，需要进行voteCount 计数，以确定是否赢得Vote，所以 Raft struct需要增加voteCount成员
协程冲突问题 Raft有如下成员来进行加锁"><meta property="og:type" content="article"><meta property="og:url" content="https://ninehills.tech/posts/ninehills-ninehills.github.io-300952316-post-62/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-02-28T09:36:26+00:00"><meta property="article:modified_time" content="2018-02-28T09:36:26+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[MIT 6.824 分布式系统课程] Lab2 Raft 心得"><meta name=twitter:description content="Raft struct 的成员 1 Raft 节点的角色，可以使用Go常量
const ( Follower = iota // 0 Candidate	// 1 Leader	// 2 ) 2 使用Buffered Channel进行异步通信，比如等待心跳包结果等情况，我定义了如下Channel
chanHeartbeat chan bool // 收到心跳 chanWinVote chan bool	// 赢得选举 chanGrantVote chan bool // 获得选举票 chanApply chan ApplyMsg // 用来commit的channel 在Make()中需要初始化Channel为Buffered Channel
rf.chanWinVote = make(chan bool, 10) rf.chanGrantVote = make(chan bool, 10) rf.chanHeartbeat = make(chan bool, 10) 3 Raft struct大部分成员都是论文的Figure 2的内容
4 发送broadcastRequestVote后，需要进行voteCount 计数，以确定是否赢得Vote，所以 Raft struct需要增加voteCount成员
协程冲突问题 Raft有如下成员来进行加锁"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ninehills.tech/posts/"},{"@type":"ListItem","position":2,"name":"[MIT 6.824 分布式系统课程] Lab2 Raft 心得","item":"https://ninehills.tech/posts/ninehills-ninehills.github.io-300952316-post-62/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[MIT 6.824 分布式系统课程] Lab2 Raft 心得","name":"[MIT 6.824 分布式系统课程] Lab2 Raft 心得","description":"Raft struct 的成员 1 Raft 节点的角色，可以使用Go常量\nconst ( Follower = iota // 0 Candidate\t// 1 Leader\t// 2 ) 2 使用Buffered Channel进行异步通信，比如等待心跳包结果等情况，我定义了如下Channel\nchanHeartbeat chan bool // 收到心跳 chanWinVote chan bool\t// 赢得选举 chanGrantVote chan bool // 获得选举票 chanApply chan ApplyMsg // 用来commit的channel 在Make()中需要初始化Channel为Buffered Channel\nrf.chanWinVote = make(chan bool, 10) rf.chanGrantVote = make(chan bool, 10) rf.chanHeartbeat = make(chan bool, 10) 3 Raft struct大部分成员都是论文的Figure 2的内容\n4 发送broadcastRequestVote后，需要进行voteCount 计数，以确定是否赢得Vote，所以 Raft struct需要增加voteCount成员\n协程冲突问题 Raft有如下成员来进行加锁","keywords":["blog","done"],"articleBody":"Raft struct 的成员 1 Raft 节点的角色，可以使用Go常量\nconst ( Follower = iota // 0 Candidate\t// 1 Leader\t// 2 ) 2 使用Buffered Channel进行异步通信，比如等待心跳包结果等情况，我定义了如下Channel\nchanHeartbeat chan bool // 收到心跳 chanWinVote chan bool\t// 赢得选举 chanGrantVote chan bool // 获得选举票 chanApply chan ApplyMsg // 用来commit的channel 在Make()中需要初始化Channel为Buffered Channel\nrf.chanWinVote = make(chan bool, 10) rf.chanGrantVote = make(chan bool, 10) rf.chanHeartbeat = make(chan bool, 10) 3 Raft struct大部分成员都是论文的Figure 2的内容\n4 发送broadcastRequestVote后，需要进行voteCount 计数，以确定是否赢得Vote，所以 Raft struct需要增加voteCount成员\n协程冲突问题 Raft有如下成员来进行加锁\nmu sync.Mutex // Lock to protect shared access to this peer's state 使用方法一般有两种，一种是在明确的边界区进行\nrf.mu.Lock() ...... rf.mu.Unlock() 还有一种是在函数头\nrf.mu.Lock() defer rf.mu.Unlock() ........ 加锁时要小心加锁，以确保不会发生死锁，能不加锁就不加锁。此外测试时使用go test -race来判断是否发生冲突\n善用 go 协程机制 一般用在异步触发，比如广播requestVote、AppendEntries或者异步Commit上\n完整实现论文中的协议，而不要靠猜测 论文中所有的协议都需要准确实现，否则很容易出错（在互联网上找到的实现中，大部分都通不过测试），几个容易出错的地方如下，都debug了很久\n// RequestVote中判断日志是否up-to-date，应该如下实现 if (rf.votedFor == -1 || rf.votedFor == args.CandidateId) \u0026\u0026 (args.LastLogTerm \u003e rf.logs[rf.getLastIndex()].Term || (args.LastLogTerm == rf.logs[rf.getLastIndex()].Term \u0026\u0026 args.LastLogIndex \u003e= rf.getLastIndex())) { // Raft determines which of two logs is more up-to-date by comparing the // index and term of the last entries in the logs. If the logs have last // entries with different terms, then the log with the later term is // more up-to-date. If the logs end with the same term, then whichever // log is longer is more up-to-date. reply.VoteGranted = true rf.votedFor = args.CandidateId } else { reply.VoteGranted = false } func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) { /*\tReceiver implementation: 1. Reply false if term \u003c currentTerm (§5.1) 2. Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm (§5.3) 3. If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it (§5.3) 4. Append any new entries not already in the log 5. If leaderCommit \u003e commitIndex, set commitIndex = min(leaderCommit, index of last new entry)\t*/ rf.mu.Lock() defer rf.mu.Unlock() rf.chanHeartbeat \u003c- true if args.Term \u003e rf.currentTerm { rf.log(\"AppendEntries Term Bigger, convert to follower\") rf.role = Follower rf.currentTerm = args.Term rf.votedFor = -1 } DPrintf(\"1 commitIndex %d lastApplied %d LastIndex %d\", rf.commitIndex, rf.lastApplied, rf.getLastIndex()) reply.Term = rf.currentTerm reply.NextTryIndex = -1\t//默认为-1，代表index--，此处为简化逻辑，除日志不匹配的其他情况都统一-- if args.Term \u003c rf.currentTerm { reply.Success = false } else if len(rf.logs) \u003c= args.PrevLogIndex || rf.logs[args.PrevLogIndex].Term != args.PrevLogTerm { // Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm (§5.3) if len(rf.logs) \u003c= args.PrevLogIndex{ DPrintf(\"logsLen(%d) prevLogIndex(%d)\", len(rf.logs), args.PrevLogIndex) } else { DPrintf(\"logsLen(%d) prevLogIndex(%d) logsTerm(%d) prevLogTerm(%d)\", len(rf.logs), args.PrevLogIndex, rf.logs[args.PrevLogIndex].Term, args.PrevLogTerm) } if len(rf.logs) \u003e args.PrevLogIndex { // 如果日志内容不匹配，找到同Term中最早的Index，直接回退到那个Index term := rf.logs[args.PrevLogIndex].Term for reply.NextTryIndex = args.PrevLogIndex - 1; reply.NextTryIndex \u003e 0 \u0026\u0026 rf.logs[reply.NextTryIndex].Term == term; reply.NextTryIndex-- {} reply.NextTryIndex++ } else { // 如果日志长度不匹配，则以当前的日志长度为准 reply.NextTryIndex = rf.getLastIndex() + 1 } reply.Success = false } else { // If an existing entry conflicts with a new one (same index but different terms), // delete the existing entry and all that follow it. // ------------------------ // The if here is crucial. If the follower has all the entries the leader sent, // the follower MUST NOT truncate its log. Any elements following the entries // sent by the leader MUST be kept. This is because we could be receiving an // outdated AppendEntries RPC from the leader, and truncating the log would // mean “taking back” entries that we may have already told the leader that // we have in our log. // ------- wrong code ------- // preLogs := rf.logs[:args.PrevLogIndex + 1] // preLogs = append(preLogs, args.Entries...) // rf.log(fmt.Sprintf(\"%d\", preLogs)) // rf.logs = preLogs // -------------------------- rf.log(fmt.Sprintf(\"Log append: rfLogs(%d) entries(%d) preLogIndex(%d)\", rf.logs, args.Entries, args.PrevLogIndex)) for i := 0; i \u003c len(args.Entries); i++ { if i + args.PrevLogIndex + 2 \u003e len(rf.logs) { // 如果Entries 长过了 rf.logs，那么直接append rf.logs = append(rf.logs, args.Entries[i]) } else if rf.logs[i + args.PrevLogIndex + 1].Term != args.Entries[i].Term { rf.logs = rf.logs[:i + args.PrevLogIndex + 1] rf.logs = append(rf.logs, args.Entries[i]) } } rf.log(fmt.Sprintf(\"Log append result: rfLogs(%d)\", rf.logs)) if args.LeaderCommit \u003e rf.commitIndex { if args.LeaderCommit \u003e rf.getLastIndex() { rf.commitIndex = rf.getLastIndex() } else { rf.commitIndex = args.LeaderCommit } if rf.commitIndex \u003e rf.lastApplied { go rf.commit() } } reply.Success = true } DPrintf(\"2 commitIndex %d lastApplied %d LastIndex %d\", rf.commitIndex, rf.lastApplied, rf.getLastIndex()) rf.log(fmt.Sprintf(\"reply AppendEntries from %d: %t\", args.LeaderId, reply.Success)) rf.persist() } // 还有 sendAppendEntries 返回成功后的处理 if reply.Success { // If successful: update nextIndex and matchIndex for follower (§5.3) // 此处注意不能简单更新为 rf.getLastIndex()，因为sendAppendEntries是异步的，send的时候最新的index有可能已经变了 rf.matchIndex[server] = args.PrevLogIndex + len(args.Entries) rf.nextIndex[server] = rf.matchIndex[server] + 1 Debug的方法 可以给Raft struce定义一个log方法，打印一些基本信息，如Term等，这样就不用每次都拼接。例如\nfunc (rf *Raft) log(message string) { // 封装日志方法 if Debug \u003e 0 { log.Printf(\"node(%d)role(%d)term(%d)commitIndex(%d)logs(%d): %s\", rf.me, rf.role, rf.currentTerm, rf.commitIndex, rf.logs, message) } } 当然这里图省事用的string，可以换成format，参见utils.go下的DPrintf的实现\n测试 测试随机性比较大，一次测试通过不能代表没问题，建议跑多轮测试都没有问题才算通过\n选举超时和心跳间隔的设定 // 选举超时，Paper中写 150–300ms 随机，测试环境是1000ms rand.Seed(time.Now().UnixNano()) electionTimeout := func() time.Duration { return time.Duration(500 + rand.Intn(150)) * time.Millisecond } // broadcastTime \u003c\u003c electionTimeout \u003c\u003c MTBF（平均无故障工作时间） // \u003c\u003c 代表数量级的差别 heartBeatInterval := time.Duration(50) * time.Millisecond 选举状态机的实现 for { rf.log(\"loop start\") rf.mu.Lock() role := rf.role rf.mu.Unlock() switch role { case Follower: // Respond to RPCs from candidates and leaders // If election timeout elapses without receiving AppendEntries RPC from current leader // or granting vote to candidate: convert to candidate select { case \u003c-rf.chanHeartbeat: case \u003c-rf.chanGrantVote: case \u003c-time.After(electionTimeout()): rf.mu.Lock() rf.log(\"follower no heartbeat/vote and timeout, convert to candidate\") rf.role = Candidate rf.mu.Unlock() } case Candidate: // On conversion to candidate, start election: // - Increment currentTerm // - Vote for self // - Reset election timer // - Send RequestVote RPCs to all other servers // If votes received from majority of servers: become leader // If AppendEntries RPC received from new leader: convert to follower // If election timeout elapses: start new election rf.mu.Lock() rf.currentTerm++ rf.votedFor = rf.me rf.voteCount = 1\t// 自己算一票 rf.persist() rf.mu.Unlock() go rf.broadcastRequestVote() select { case \u003c-rf.chanWinVote: rf.mu.Lock() if len(rf.chanHeartbeat) \u003e 0 { \u003c-rf.chanHeartbeat } rf.log(\"win vote, convert to leader\") if rf.role != Leader { // 有一种情况是 chanWinVote 和 chanHeartbeat同时收到消息，这时候Go会随机选择一个case // 但是 chanWinVote中的数据还在，会干扰到下次选举 // 临时的解决办法是在配置chanWinVote的时候同时设定role，此处二次验证 rf.log(\"chanWinVote has outdated message, ignore it.\") continue } // 初始化leader的变量 rf.nextIndex = make([]int, len(rf.peers)) rf.matchIndex = make([]int, len(rf.peers)) for i := range rf.peers { rf.nextIndex[i] = rf.getLastIndex() + 1 rf.matchIndex[i] = 0 } rf.mu.Unlock() case \u003c-rf.chanHeartbeat: rf.mu.Lock() rf.log(\"received heartbeat, convert to follower\") rf.role = Follower rf.mu.Unlock() case \u003c-time.After(electionTimeout()): rf.log(\"election timeout, skip\") } case Leader: // Upon election: send initial empty AppendEntries RPCs (heartbeat) to each server; // repeat during idle periods to prevent election timeouts (§5.2) // If command received from client: append entry to local log, // respond after entry applied to state machine (§5.3) // If last log index ≥ nextIndex for a follower: // send AppendEntries RPC with log entries starting at nextIndex // - If successful: update nextIndex and matchIndex for follower (§5.3) // - If AppendEntries fails because of log inconsistency: // decrement nextIndex and retry (§5.3) // If there exists an N such that N \u003e commitIndex, a majority // of matchIndex[i] ≥ N, and log[N].term == currentTerm: // set commitIndex = N (§5.3, §5.4). rf.broadcastAppendEntries() time.Sleep(heartBeatInterval) } } 追求代码的美 在完成的过程中以及完成后，因为没有人帮忙判卷，看了一些现在互联网已经有的实现作为参考，总的来说，都只是为了完成而完成，注释也好、代码组织形式也好都不是很重视。可能过上几个月就忘记了以前为什么这么写的原因，这点对于Raft协议这种实现的稍微有点差池就出大问题的，非常重要。\n因为这个课程不希望大家Public代码，所以没有公开代码，有需要的可以单独发邮件索取。\n选举状态机的实现里, 在sleep心跳时长的时候, 没有办法接受处理AppendEntriesRPC\nbroadcastAppendEntries()里会用协程的方式启动多个 sendAppendEntries，Reply由此处理。\n","wordCount":"1117","inLanguage":"en","datePublished":"2018-02-28T09:36:26Z","dateModified":"2018-02-28T09:36:26Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ninehills.tech/posts/ninehills-ninehills.github.io-300952316-post-62/"},"publisher":{"@type":"Organization","name":"九原山","logo":{"@type":"ImageObject","url":"https://ninehills.tech/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ninehills.tech/ accesskey=h title="九原山 (Alt + H)">九原山</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[MIT 6.824 分布式系统课程] Lab2 Raft 心得</h1><div class=post-meta><span title='2018-02-28 09:36:26 +0000 UTC'>February 28, 2018</span></div></header><div class=post-content><h1 id=raft-struct-的成员>Raft struct 的成员<a hidden class=anchor aria-hidden=true href=#raft-struct-的成员>#</a></h1><p>1 Raft 节点的角色，可以使用Go常量</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Follower</span> = <span style=color:#66d9ef>iota</span>         <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Candidate</span>		<span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Leader</span>			<span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span></code></pre></div><p>2 使用Buffered Channel进行异步通信，比如等待心跳包结果等情况，我定义了如下Channel</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>	<span style=color:#a6e22e>chanHeartbeat</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// 收到心跳
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>chanWinVote</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>	<span style=color:#75715e>// 赢得选举
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>chanGrantVote</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// 获得选举票
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>chanApply</span> <span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>ApplyMsg</span> <span style=color:#75715e>// 用来commit的channel
</span></span></span></code></pre></div><p>在<code>Make()</code>中需要初始化Channel为Buffered Channel</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>chanWinVote</span> = make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>, <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>chanGrantVote</span> = make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>, <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>chanHeartbeat</span> = make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>, <span style=color:#ae81ff>10</span>)
</span></span></code></pre></div><p>3 Raft struct大部分成员都是论文的Figure 2的内容</p><p>4 发送broadcastRequestVote后，需要进行voteCount 计数，以确定是否赢得Vote，所以 Raft struct需要增加voteCount成员</p><h1 id=协程冲突问题>协程冲突问题<a hidden class=anchor aria-hidden=true href=#协程冲突问题>#</a></h1><p>Raft有如下成员来进行加锁</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#a6e22e>mu</span>        <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>          <span style=color:#75715e>// Lock to protect shared access to this peer&#39;s state
</span></span></span></code></pre></div><p>使用方法一般有两种，一种是在明确的边界区进行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span><span style=color:#f92672>......</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span></code></pre></div><p>还有一种是在函数头</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span><span style=color:#f92672>......</span>..
</span></span></code></pre></div><p>加锁时要小心加锁，以确保不会发生死锁，能不加锁就不加锁。此外测试时使用<code>go test -race</code>来判断是否发生冲突</p><h1 id=善用-go-协程机制>善用 go 协程机制<a hidden class=anchor aria-hidden=true href=#善用-go-协程机制>#</a></h1><p>一般用在异步触发，比如广播requestVote、AppendEntries或者异步Commit上</p><h1 id=完整实现论文中的协议而不要靠猜测>完整实现论文中的协议，而不要靠猜测<a hidden class=anchor aria-hidden=true href=#完整实现论文中的协议而不要靠猜测>#</a></h1><p>论文中所有的协议都需要准确实现，否则很容易出错（在互联网上找到的实现中，大部分都通不过测试），几个容易出错的地方如下，都debug了很久</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#75715e>// RequestVote中判断日志是否up-to-date，应该如下实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>votedFor</span> <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>votedFor</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>CandidateId</span>) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>			(<span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>LastLogTerm</span> &gt; <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>[<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>getLastIndex</span>()].<span style=color:#a6e22e>Term</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>				(<span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>LastLogTerm</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>[<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>getLastIndex</span>()].<span style=color:#a6e22e>Term</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>LastLogIndex</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>getLastIndex</span>())) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Raft determines which of two logs is more up-to-date by comparing the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// index and term of the last entries in the logs. If the logs have last
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// entries with different terms, then the log with the later term is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// more up-to-date. If the logs end with the same term, then whichever
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// log is longer is more up-to-date.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>VoteGranted</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>votedFor</span> = <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>CandidateId</span>
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>VoteGranted</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Raft</span>) <span style=color:#a6e22e>AppendEntries</span>(<span style=color:#a6e22e>args</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>AppendEntriesArgs</span>, <span style=color:#a6e22e>reply</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>AppendEntriesReply</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*	Receiver implementation:
</span></span></span><span style=display:flex><span><span style=color:#75715e>	1. Reply false if term &lt; currentTerm (§5.1)
</span></span></span><span style=display:flex><span><span style=color:#75715e>	2. Reply false if log doesn’t contain an entry at prevLogIndex
</span></span></span><span style=display:flex><span><span style=color:#75715e>	whose term matches prevLogTerm (§5.3)
</span></span></span><span style=display:flex><span><span style=color:#75715e>	3. If an existing entry conflicts with a new one (same index
</span></span></span><span style=display:flex><span><span style=color:#75715e>	but different terms), delete the existing entry and all that
</span></span></span><span style=display:flex><span><span style=color:#75715e>	follow it (§5.3)
</span></span></span><span style=display:flex><span><span style=color:#75715e>	4. Append any new entries not already in the log
</span></span></span><span style=display:flex><span><span style=color:#75715e>	5. If leaderCommit &gt; commitIndex, set commitIndex =
</span></span></span><span style=display:flex><span><span style=color:#75715e>		min(leaderCommit, index of last new entry)	*/</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>chanHeartbeat</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>Term</span> &gt; <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>currentTerm</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;AppendEntries Term Bigger, convert to follower&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>role</span> = <span style=color:#a6e22e>Follower</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>currentTerm</span> = <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>Term</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>votedFor</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>DPrintf</span>(<span style=color:#e6db74>&#34;1 commitIndex %d lastApplied %d LastIndex %d&#34;</span>, <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>commitIndex</span>, <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>lastApplied</span>, <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>getLastIndex</span>())
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>Term</span> = <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>currentTerm</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>NextTryIndex</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>	<span style=color:#75715e>//默认为-1，代表index--，此处为简化逻辑，除日志不匹配的其他情况都统一--
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>Term</span> &lt; <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>currentTerm</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>Success</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>) <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogIndex</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>[<span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogIndex</span>].<span style=color:#a6e22e>Term</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogTerm</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm (§5.3)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>) <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogIndex</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>DPrintf</span>(<span style=color:#e6db74>&#34;logsLen(%d) prevLogIndex(%d)&#34;</span>,
</span></span><span style=display:flex><span>				len(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>), <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogIndex</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>DPrintf</span>(<span style=color:#e6db74>&#34;logsLen(%d) prevLogIndex(%d) logsTerm(%d) prevLogTerm(%d)&#34;</span>,
</span></span><span style=display:flex><span>				len(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>), <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogIndex</span>, <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>[<span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogIndex</span>].<span style=color:#a6e22e>Term</span>, <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogTerm</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>) &gt; <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogIndex</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 如果日志内容不匹配，找到同Term中最早的Index，直接回退到那个Index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>term</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>[<span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogIndex</span>].<span style=color:#a6e22e>Term</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>NextTryIndex</span> = <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogIndex</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>NextTryIndex</span> &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>[<span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>NextTryIndex</span>].<span style=color:#a6e22e>Term</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>term</span>; <span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>NextTryIndex</span><span style=color:#f92672>--</span> {}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>NextTryIndex</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 如果日志长度不匹配，则以当前的日志长度为准
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>NextTryIndex</span> = <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>getLastIndex</span>() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>Success</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// If an existing entry conflicts with a new one (same index but different terms),
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// delete the existing entry and all that follow it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// ------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// The if here is crucial. If the follower has all the entries the leader sent,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// the follower MUST NOT truncate its log. Any elements following the entries
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// sent by the leader MUST be kept. This is because we could be receiving an
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// outdated AppendEntries RPC from the leader, and truncating the log would
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// mean “taking back” entries that we may have already told the leader that
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// we have in our log.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// ------- wrong code -------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// preLogs := rf.logs[:args.PrevLogIndex + 1]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// preLogs = append(preLogs, args.Entries...)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// rf.log(fmt.Sprintf(&#34;%d&#34;, preLogs))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// rf.logs = preLogs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// --------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;Log append: rfLogs(%d) entries(%d) preLogIndex(%d)&#34;</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>, <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>Entries</span>, <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogIndex</span>))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>Entries</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogIndex</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> &gt; len(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>) {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// 如果Entries 长过了 rf.logs，那么直接append
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span> = append(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>, <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>Entries</span>[<span style=color:#a6e22e>i</span>])
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogIndex</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>].<span style=color:#a6e22e>Term</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>Entries</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Term</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span> = <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>[:<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogIndex</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span> = append(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>, <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>Entries</span>[<span style=color:#a6e22e>i</span>])
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;Log append result: rfLogs(%d)&#34;</span>, <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>LeaderCommit</span> &gt; <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>commitIndex</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>LeaderCommit</span> &gt; <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>getLastIndex</span>() {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>commitIndex</span> = <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>getLastIndex</span>()
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>commitIndex</span> = <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>LeaderCommit</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>commitIndex</span> &gt; <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>lastApplied</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>commit</span>()
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>Success</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>DPrintf</span>(<span style=color:#e6db74>&#34;2 commitIndex %d lastApplied %d LastIndex %d&#34;</span>, <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>commitIndex</span>, <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>lastApplied</span>, <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>getLastIndex</span>())
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;reply AppendEntries from %d: %t&#34;</span>, <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>LeaderId</span>, <span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>Success</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>persist</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#75715e>// 还有  sendAppendEntries 返回成功后的处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>Success</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// If successful: update nextIndex and matchIndex for follower (§5.3)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 此处注意不能简单更新为 rf.getLastIndex()，因为sendAppendEntries是异步的，send的时候最新的index有可能已经变了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>matchIndex</span>[<span style=color:#a6e22e>server</span>] = <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>PrevLogIndex</span> <span style=color:#f92672>+</span> len(<span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>Entries</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>nextIndex</span>[<span style=color:#a6e22e>server</span>] = <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>matchIndex</span>[<span style=color:#a6e22e>server</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><h1 id=debug的方法>Debug的方法<a hidden class=anchor aria-hidden=true href=#debug的方法>#</a></h1><p>可以给Raft struce定义一个log方法，打印一些基本信息，如Term等，这样就不用每次都拼接。例如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Raft</span>) <span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>message</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 封装日志方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>Debug</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;node(%d)role(%d)term(%d)commitIndex(%d)logs(%d): %s&#34;</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>me</span>, <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>role</span>, <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>currentTerm</span>, <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>commitIndex</span>, <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>logs</span>, <span style=color:#a6e22e>message</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当然这里图省事用的string，可以换成format，参见utils.go下的DPrintf的实现</p><h1 id=测试>测试<a hidden class=anchor aria-hidden=true href=#测试>#</a></h1><p>测试随机性比较大，一次测试通过不能代表没问题，建议跑多轮测试都没有问题才算通过</p><h1 id=选举超时和心跳间隔的设定>选举超时和心跳间隔的设定<a hidden class=anchor aria-hidden=true href=#选举超时和心跳间隔的设定>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>	<span style=color:#75715e>// 选举超时，Paper中写 150–300ms 随机，测试环境是1000ms
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Seed</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>().<span style=color:#a6e22e>UnixNano</span>())
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>electionTimeout</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>() <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>(<span style=color:#ae81ff>500</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#ae81ff>150</span>)) <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF（平均无故障工作时间）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// &lt;&lt; 代表数量级的差别
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>heartBeatInterval</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>(<span style=color:#ae81ff>50</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>
</span></span></code></pre></div><h1 id=选举状态机的实现>选举状态机的实现<a hidden class=anchor aria-hidden=true href=#选举状态机的实现>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;loop start&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>role</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>role</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>role</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Follower</span>:
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Respond to RPCs from candidates and leaders
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// If election timeout elapses without receiving AppendEntries RPC from current leader
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// or granting vote to candidate: convert to candidate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>chanHeartbeat</span>:
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>chanGrantVote</span>:
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>After</span>(<span style=color:#a6e22e>electionTimeout</span>()):
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;follower no heartbeat/vote and timeout, convert to candidate&#34;</span>)
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>role</span> = <span style=color:#a6e22e>Candidate</span>
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Candidate</span>:
</span></span><span style=display:flex><span>			<span style=color:#75715e>// On conversion to candidate, start election:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// - Increment currentTerm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// - Vote for self
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// - Reset election timer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// - Send RequestVote RPCs to all other servers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// If votes received from majority of servers: become leader
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// If AppendEntries RPC received from new leader: convert to follower
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// If election timeout elapses: start new election
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>currentTerm</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>votedFor</span> = <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>me</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>voteCount</span> = <span style=color:#ae81ff>1</span>	<span style=color:#75715e>// 自己算一票
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>persist</span>()
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>broadcastRequestVote</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>chanWinVote</span>:
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>chanHeartbeat</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>					<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>chanHeartbeat</span>
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;win vote, convert to leader&#34;</span>)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>role</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>Leader</span> {
</span></span><span style=display:flex><span>					<span style=color:#75715e>// 有一种情况是 chanWinVote 和 chanHeartbeat同时收到消息，这时候Go会随机选择一个case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>					<span style=color:#75715e>// 但是 chanWinVote中的数据还在，会干扰到下次选举
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>					<span style=color:#75715e>// 临时的解决办法是在配置chanWinVote的时候同时设定role，此处二次验证
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>					<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;chanWinVote has outdated message, ignore it.&#34;</span>)
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#75715e>// 初始化leader的变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>nextIndex</span> = make([]<span style=color:#66d9ef>int</span>, len(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>peers</span>))
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>matchIndex</span> = make([]<span style=color:#66d9ef>int</span>, len(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>peers</span>))
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>peers</span> {
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>nextIndex</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>getLastIndex</span>() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>matchIndex</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>chanHeartbeat</span>:
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;received heartbeat, convert to follower&#34;</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>role</span> = <span style=color:#a6e22e>Follower</span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>After</span>(<span style=color:#a6e22e>electionTimeout</span>()):
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;election timeout, skip&#34;</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Leader</span>:
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Upon election: send initial empty AppendEntries RPCs (heartbeat) to each server;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// 		repeat during idle periods to prevent election timeouts (§5.2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// If command received from client: append entry to local log,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// 		respond after entry applied to state machine (§5.3)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// If last log index ≥ nextIndex for a follower:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// 		send AppendEntries RPC with log entries starting at nextIndex
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// - If successful: update nextIndex and matchIndex for follower (§5.3)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// - If AppendEntries fails because of log inconsistency:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// 		decrement nextIndex and retry (§5.3)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// If there exists an N such that N &gt; commitIndex, a majority
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// 		of matchIndex[i] ≥ N, and log[N].term == currentTerm:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// 		set commitIndex = N (§5.3, §5.4).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>broadcastAppendEntries</span>()
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>heartBeatInterval</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><h1 id=追求代码的美>追求代码的美<a hidden class=anchor aria-hidden=true href=#追求代码的美>#</a></h1><p>在完成的过程中以及完成后，因为没有人帮忙判卷，看了一些现在互联网已经有的实现作为参考，总的来说，都只是为了完成而完成，注释也好、代码组织形式也好都不是很重视。可能过上几个月就忘记了以前为什么这么写的原因，这点对于Raft协议这种实现的稍微有点差池就出大问题的，非常重要。</p><p>因为这个课程不希望大家Public代码，所以没有公开代码，有需要的可以单独发邮件索取。</p><blockquote><p>选举状态机的实现里, 在sleep心跳时长的时候, 没有办法接受处理AppendEntriesRPC</p></blockquote><p>broadcastAppendEntries()里会用协程的方式启动多个 sendAppendEntries，Reply由此处理。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ninehills.tech/tags/blog/>blog</a></li><li><a href=https://ninehills.tech/tags/done/>done</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://ninehills.tech/>九原山</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>